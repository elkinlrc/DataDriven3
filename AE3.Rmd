---
title: "AE3"
author: "Dario Chávez & Elkin Rodríguez"
date: "`r Sys.Date()`"
output: html_document
---

## Suprimir mensajes de advertencia al cargar 'dplyr'

capture.output(suppressPackageStartupMessages(library(dplyr)), type = "message")

## Cargar librerías

library(readr) library(stringr) library(dplyr) library(ggplot2)
library(mltools) library(data.table) library(tidyr) library(lubridate)

## Pregunta 1

Descomprimir el fichero comprimido que contiene los registros del 
servidor, y a partir de los datos extraídos, cargar en data frame los 
registros con las peticiones servidas.  

```{r setup1, include=TRUE}

##PREGUNTA 1.1
## Cargar librerías
library(readr)
library(stringr)
library(dplyr)
library(ggplot2)
library(mltools)
library(data.table)
library(tidyr)
library(lubridate)

# Cargar el archivo que contiene la función procesar_dataset
source("procesar_dataset.R")

# Función para descomprimir el archivo
descomprimir_archivo <- function(zip_path, output_dir = "datos") {
  if (!dir.exists(output_dir)) {
    dir.create(output_dir) # Crear directorio si no existe
  }
  unzip(zip_path, exdir = output_dir)
  cat("Archivo descomprimido en:", output_dir, "\n")
  
  # Retornar la ruta del archivo extraído
  list.files(output_dir, full.names = TRUE)
}
```

## Pregunta 2

Incluid en el documento un apartado con la descripción de los datos 
analizados: fuente, tipología, descripción de la información contenida 
(los diferentes campos) y sus valores. 

```{r setup2, include=TRUE}
# Función para describir el dataset
describir_datos <- function(dataset) {
  cat("\n--- Descripción de los datos ---\n")
  cat("1. Fuente: Logs de servidor Apache\n")
  cat("2. Tipología: Peticiones HTTP procesadas por el servidor\n")
  cat("3. Campos:\n")
  cat("   - Site: Dirección IP del cliente\n")
  cat("   - Timestamp: Fecha y hora de la petición\n")
  cat("   - Metodo: Método HTTP usado (GET, POST, etc.)\n")
  cat("   - Endpoint: Recurso solicitado\n")
  cat("   - Protocolo: Versión del protocolo HTTP\n")
  cat("   - Respuesta_http: Código de estado HTTP\n")
  cat("   - Bytes: Tamaño de la respuesta en bytes\n")
  cat("\nValores de ejemplo:\n")
  print(head(dataset))
}

```

## Pregunta 3

Aprovechando que los datos a analizar son los mismos de la primera 
práctica, para esta entrega es imprescindible que los datos estén en 
formato de “datos elegantes”. 

```{r setup3, include=TRUE}
##La limpieza y formateo se realiza en la funcion de procesamiento del dataset
procesar_dataset <- function(file_path = "datos/epa-http.csv") {
  # Leer y procesar el archivo
  dataset <- suppressWarnings(read_table(
    file_path,
    col_names = FALSE,
    na = c("", "NA", "NULL"),
    col_types = cols(
      X1 = col_character(),
      X2 = col_character(),
      X3 = col_character(),
      X4 = col_character(),
      X5 = col_character(),
      X6 = col_integer(),
      X7 = col_integer()
    )
  ))
  
  # Reemplazar valores NA
  dataset$X6[is.na(dataset$X6)] <- 0
  dataset$X7[is.na(dataset$X7)] <- 0
  
  # Cambiar nombres de columnas
  colnames(dataset) <- c("Site", "Timestamp", "Metodo", "Endpoint", "Protocolo", "Respuesta_http", "Bytes")
  
  # Limpiar columnas
  dataset$Metodo <- str_replace_all(dataset$Metodo, '"', "")
  dataset$Protocolo <- str_replace_all(dataset$Protocolo, '"', "")
  dataset$Timestamp <- str_replace_all(dataset$Timestamp, "\\[|\\]", "")
  # Procesar el Timestamp (separar y convertir)
 
  #no se encontro una el anyo ni el dia entonces se toma por defecto 2025-01
  # Dividir el Timestamp en Día, Hora, Minuto, Segundo
  dataset <- dataset %>%
    mutate(
      Dia = as.numeric(str_split_fixed(Timestamp, ":", 4)[, 1]),
      Hora = as.numeric(str_split_fixed(Timestamp, ":", 4)[, 2]),
      Minuto = as.numeric(str_split_fixed(Timestamp, ":", 4)[, 3]),
      Segundo = as.numeric(str_split_fixed(Timestamp, ":", 4)[, 4])
    )
  
  # Crear la columna FechaHora
  dataset <- dataset %>%
    mutate(
      FechaHora = as.POSIXct("2025-01-01 00:00:00", tz = "UTC") +
        days(Dia - 1) + hours(Hora) + minutes(Minuto) + seconds(Segundo)
    )
  
  dataset$FechaHora <- as.POSIXct(dataset$FechaHora, format = "%Y-%m-%d %H:%M:%S")
  
  # Crear columna adicional para longitud de Endpoint
  dataset <- dataset %>% mutate(Longitud_Endpoint = str_length(Endpoint))
  
  return(dataset)
}

```

## Pregunta 4

Identificar el número único de usuarios que han interactuado 
directamente con el servidor de forma segregada según si los usuarios 
han tenido algún tipo de error en las distintas peticiones ofrecidas por el
servidor. 

```{r setup4, include=TRUE}


```

## Pregunta 5

Analizar los distintos tipos de peticiones HTTP (GET, POST, PUT, DELETE) 
gestionadas por el servidor, identificando la frecuencia de cada una de 
estas. Repetir el análisis, esta vez filtrando previamente aquellas 
peticiones correspondientes a recursos ofrecidos de tipo imagen.  

```{r setup5, include=TRUE}


```

## Pregunta 6

Generar al menos 2 gráficos distintos que permitan visualizar alguna 
característica relevante de los datos analizados.    

Estos deberán representar por lo menos 1 o 2 variables diferentes del 
data frame. Describid el gráfico e indicad cualquier observación 
destacable que se pueda apreciar gracias a la representación gráfica.

```{r setup6, include=TRUE}


```

## Pregunta 7

Generar un gráfico que permita visualizar el número de peticiones 
servidas a lo largo del tiempo. 

```{r setup7, include=TRUE}


```

## Pregunta 8

Utilizando un algoritmo de aprendizaje no supervisado, realizad un 
análisis de clústering con k-means para los datos del servidor.  

```{r setup8, include=TRUE}


```

## Pregunta 9

Representad visualmente en gráficos de tipo scatter plot el resultado de 
vuestros clústering y interpretad el resultado obtenido (describid las 
características de los distintos grupos) con los 2 valores distintos de k 
probados en el apartado anterior en función de los valores de las variables y el número de clúster asignado.   

```{r setup9, include=TRUE}


```